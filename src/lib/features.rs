use std::path::Path;
use std::fs::{self, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use anyhow::{Result, bail};
use toml_edit::{Document, Item, Array, value};

pub fn create_feature(feature_name: &str) -> Result<()> {
    let feat_name = feature_name.replace("-", "_");
    if !feat_name.chars().all(|c| c.is_ascii_lowercase() || c == '_' || c.is_ascii_digit()) {
        bail!("Feature name must be lowercase, digits, hyphens or underscores only!")
    }

    let features_dir = Path::new("src/features");
    let newfeat_file = features_dir.join(&feat_name).with_extension("rs");

    let content = format!(
        r#"// {0} module
use std::time::Instant;

pub fn init() {{
    let start = Instant::now();
    println!("[*] Initializing {0} module...");

    // Your implementation here

    println!("[!] {0} initialized in {{:?}}", start.elapsed());
}}
"#,
        feat_name
    );
    fs::write(newfeat_file, content)?;

    println!("[!] Created new feature: src/features/{}", feat_name);
    println!("[!] Don't forget to add '{}' to your build_profiles/*.yml!", feat_name);
    Ok(())
}

pub fn register_feature_in_mod_rs(feature_name: &str) -> Result<()> {
    println!("[*] Registering new features to mod.rs...");
    let mod_path = Path::new("src/features/mod.rs");
    if !mod_path.exists() {
        fs::write(&mod_path, "// Auto-generated by xbuild\n")?;
    }

    let file = fs::File::open(&mod_path)?;
    let reader = BufReader::new(file);
    let already_exists = reader
        .lines()
        .filter_map(Result::ok)
        .any(|line| line.trim() == format!("pub mod {};", feature_name));

    if !already_exists {
        let file = OpenOptions::new().append(true).open(&mod_path);
        writeln!(file?, "pub mod {};", feature_name);
        println!("[*] Registered feature '{}' in features/mod.rs", feature_name);
    } else {
        println!("[*] Feature '{}' already registered in features/mod.rs", feature_name);
    }
    Ok(())
}

pub fn list_registered_features() -> Result<Vec<String>> {
    let mod_path = Path::new("src/features/mod.rs");
    let file = fs::File::open(mod_path)?;
    let reader = BufReader::new(file);
    let mut features = vec![];

    for line in reader.lines() {
        let line = line?;
        if line.trim().starts_with("pub mod ") {
            if let Some(name) = line.trim().strip_prefix("pub mod") {
                if let Some(name) = name.strip_suffix(";") {
                    features.push(name.trim().to_string());
                }
            }
        }
    }

    Ok(features)
}

pub fn patch_cargo_toml_with_feat(features: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    let cargo_toml_path = "Cargo.toml";
    let toml_str = fs::read_to_string(cargo_toml_path)?;
    let mut doc = toml_str.parse::<Document>()?;
    
    if !doc.as_table().contains_key("features") {
        doc["features"] = Item::Table(Default::default());
    }

    let features_table = doc["features"].as_table_mut().unwrap();
    for feature in features {
        if !features_table.contains_key(feature){
            let arr = Array::new();
            features_table[feature] = Item::Value(toml_edit::Value::Array(arr));
        }
    }

    fs::write(cargo_toml_path, doc.to_string())?;
    println!("[+] Patched Cargo.toml with {} feature(s)", features.len());
    Ok(())
}